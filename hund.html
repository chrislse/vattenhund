<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>古代水壶倒水场景（改进版 4 - 日落渐变天空盒与草地）</title>
    <style>
        body { margin: 0; overflow: hidden; }
        canvas { display: block; }
    </style>
</head>
<body>
    <!-- 引入 Three.js 库 -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r134/three.min.js"></script>
    <script>
        // 初始化场景、相机和渲染器
        const scene = new THREE.Scene();
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        const renderer = new THREE.WebGLRenderer();
        renderer.setSize(window.innerWidth, window.innerHeight);
        document.body.appendChild(renderer.domElement);

        // 添加天空盒（渐变日落效果）
        function createSkybox() {
            const skyboxGeometry = new THREE.BoxGeometry(500, 500, 500);

            const vertexShader = `
                varying vec3 vWorldPosition;
                void main() {
                    vWorldPosition = (modelMatrix * vec4(position, 1.0)).xyz;
                    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
                }
            `;

            const fragmentShader = `
                varying vec3 vWorldPosition;
                void main() {
                    float height = normalize(vWorldPosition).y;
                    vec3 sunsetBottom = vec3(0.8, 0.2, 0.0);    // 深橙色
                    vec3 sunsetMiddle = vec3(1.0, 0.5, 0.2);    // 浅橙色
                    vec3 sunsetTop = vec3(0.5, 0.2, 0.6);       // 紫色
                    
                    vec3 color;
                    if (height < 0.0) {
                        color = mix(sunsetBottom, sunsetMiddle, (height + 1.0) / 1.0);
                    } else {
                        color = mix(sunsetMiddle, sunsetTop, height);
                    }
                    
                    gl_FragColor = vec4(color, 1.0);
                }
            `;

            const skyboxMaterial = new THREE.ShaderMaterial({
                vertexShader: vertexShader,
                fragmentShader: fragmentShader,
                side: THREE.BackSide
            });

            const skybox = new THREE.Mesh(skyboxGeometry, skyboxMaterial);
            scene.add(skybox);
        }

        // 创建天空盒
        createSkybox();

        // 添加光源
        const ambientLight = new THREE.AmbientLight(0x404040);
        scene.add(ambientLight);
        const directionalLight = new THREE.DirectionalLight(0xffffff, 0.5);
        directionalLight.position.set(0, 1, 1);
        scene.add(directionalLight);

        // 创建地面（渐变草绿色）
        const groundGeometry = new THREE.PlaneGeometry(10, 10);
        const groundShaderMaterial = new THREE.ShaderMaterial({
            vertexShader: `
                varying vec3 vWorldPosition;
                void main() {
                    vWorldPosition = (modelMatrix * vec4(position, 1.0)).xyz;
                    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
                }
            `,
            fragmentShader: `
                varying vec3 vWorldPosition;
                void main() {
                    // 基于 Z 轴距离计算渐变（相机朝向负Z方向）
                    float depth = (vWorldPosition.z + 5.0) / 10.0; // 归一化到 0-1
                    vec3 lightGreen = vec3(0.6, 0.9, 0.3);  // 浅绿色
                    vec3 darkGreen = vec3(0.2, 0.5, 0.1);   // 深绿色
                    vec3 color = mix(lightGreen, darkGreen, depth);
                    gl_FragColor = vec4(color, 1.0);
                }
            `,
            side: THREE.DoubleSide
        });
        const ground = new THREE.Mesh(groundGeometry, groundShaderMaterial);
        ground.rotation.x = -Math.PI / 2;
        scene.add(ground);

        // 创建水壶函数（壶嘴朝向中间）
        function createKettle(position, isLeft) {
            const kettleGroup = new THREE.Group();
            const bodyGeometry = new THREE.CylinderGeometry(0.3, 0.3, 0.8, 32);
            const bodyMaterial = new THREE.MeshPhongMaterial({ color: 0xA0522D });
            const kettleBody = new THREE.Mesh(bodyGeometry, bodyMaterial);
            kettleGroup.add(kettleBody);

            const spoutGeometry = new THREE.ConeGeometry(0.1, 0.3, 32);
            const spoutMaterial = new THREE.MeshPhongMaterial({ color: 0xA0522D });
            const spout = new THREE.Mesh(spoutGeometry, spoutMaterial);
            spout.position.set(isLeft ? 0.3 : -0.3, 0.2, 0);
            spout.rotation.z = isLeft ? -Math.PI / 2 : Math.PI / 2;
            kettleGroup.add(spout);

            kettleGroup.position.copy(position);
            kettleGroup.rotation.z = 0;
            kettleGroup.isPouring = false;
            scene.add(kettleGroup);
            return kettleGroup;
        }

        // 创建两个水壶
        const kettle1 = createKettle(new THREE.Vector3(-0.7, 1.2, 0), true);  // 左水壶
        const kettle2 = createKettle(new THREE.Vector3(0.7, 1.2, 0), false);   // 右水壶

        // 创建浅色带花纹的碗
        const bowlGeometry = new THREE.CylinderGeometry(0.5, 0.5, 0.2, 32, 1, true);
        const bowlMaterial = new THREE.MeshPhongMaterial({ 
            color: 0xF0F8FF,
            transparent: true, 
            opacity: 0.8,
            side: THREE.DoubleSide,
            map: new THREE.TextureLoader().load('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAAABmJLR0QA/wD/AP+gvaeTAAAAdElEQVRYhe3TsQ3AIAwF0J/aS7u2QSu1SxvQRjOYeQ8OJF/AiIgIiIiIiIiIiIiIiIiIiIiIiIiIiIiIiIiIiIiIiIiIiIiIiIiIiIiIiIiIiIiIiIiIiIiIiIiIiIiIiIiIiIiIiIiIiIiIiIiIiIiIiIh8wYc7J2S8nWvVAAAAAElFTkSuQmCC')
        });
        const bowl = new THREE.Mesh(bowlGeometry, bowlMaterial);
        bowl.position.set(0, 0.1, 0);
        scene.add(bowl);

        // 创建碗中的水面
        const waterSurfaceGeometry = new THREE.CircleGeometry(0.48, 32);
        const waterSurfaceMaterial = new THREE.MeshPhongMaterial({ 
            color: 0x00aaff, 
            transparent: true, 
            opacity: 0.5 
        });
        const waterSurface = new THREE.Mesh(waterSurfaceGeometry, waterSurfaceMaterial);
        waterSurface.rotation.x = -Math.PI / 2;
        waterSurface.position.set(0, 0, 0);
        scene.add(waterSurface);

        // 创建小狗（浅灰色，带耳朵、尾巴和鼻子）
        const dogGroup = new THREE.Group();
        const dogMaterial = new THREE.MeshPhongMaterial({ color: 0xC0C0C0 }); // 浅灰色
        const bodyGeometry = new THREE.BoxGeometry(0.4, 0.2, 0.2);
        const dogBody = new THREE.Mesh(bodyGeometry, dogMaterial);
        dogBody.position.set(0, 0.1, 0);
        dogGroup.add(dogBody);

        const headGeometry = new THREE.SphereGeometry(0.15, 32, 32);
        const dogHead = new THREE.Mesh(headGeometry, dogMaterial);
        dogHead.position.set(0.25, 0.25, 0);
        dogGroup.add(dogHead);

        // 添加耳朵
        const earGeometry = new THREE.ConeGeometry(0.05, 0.15, 32);
        const ear1 = new THREE.Mesh(earGeometry, dogMaterial);
        ear1.position.set(0.25, 0.4, 0.1);
        ear1.rotation.x = Math.PI / 6;
        dogGroup.add(ear1);
        const ear2 = new THREE.Mesh(earGeometry, dogMaterial);
        ear2.position.set(0.25, 0.4, -0.1);
        ear2.rotation.x = -Math.PI / 6;
        dogGroup.add(ear2);

        // 添加尾巴
        const tailGeometry = new THREE.ConeGeometry(0.05, 0.2, 32);
        const tail = new THREE.Mesh(tailGeometry, dogMaterial);
        tail.position.set(-0.25, 0.25, 0);
        tail.rotation.z = Math.PI / 4;
        dogGroup.add(tail);

        // 添加黑色鼻子
        const noseGeometry = new THREE.SphereGeometry(0.03, 16, 16);
        const noseMaterial = new THREE.MeshPhongMaterial({ color: 0x000000 });
        const nose = new THREE.Mesh(noseGeometry, noseMaterial);
        nose.position.set(0.4, 0.25, 0);
        dogGroup.add(nose);

        const legGeometry = new THREE.CylinderGeometry(0.05, 0.05, 0.2, 32);
        const leg1 = new THREE.Mesh(legGeometry, dogMaterial);
        leg1.position.set(0.15, -0.1, 0.1);
        dogGroup.add(leg1);
        const leg2 = new THREE.Mesh(legGeometry, dogMaterial);
        leg2.position.set(0.15, -0.1, -0.1);
        dogGroup.add(leg2);
        const leg3 = new THREE.Mesh(legGeometry, dogMaterial);
        leg3.position.set(-0.15, -0.1, 0.1);
        dogGroup.add(leg3);
        const leg4 = new THREE.Mesh(legGeometry, dogMaterial);
        leg4.position.set(-0.15, -0.1, -0.1);
        dogGroup.add(leg4);

        dogGroup.position.set(0, 0.1, -0.8);
        scene.add(dogGroup);

        // 创建水流粒子系统
        const waterMaterial = new THREE.MeshBasicMaterial({ color: 0x00aaff });
        const waterParticles = new THREE.Group();
        scene.add(waterParticles);

        function createWaterParticle(position) {
            const geometry = new THREE.SphereGeometry(0.02, 8, 8);
            const particle = new THREE.Mesh(geometry, waterMaterial);
            particle.position.copy(position);
            particle.velocity = new THREE.Vector3(
                (Math.random() - 0.5) * 0.02,
                -Math.random() * 0.05 - 0.05,
                (Math.random() - 0.5) * 0.02
            );
            waterParticles.add(particle);
        }

        // 设置相机位置
        camera.position.set(0, 1, 3);
        camera.lookAt(0, 0, 0);

        // 鼠标点击交互
        const raycaster = new THREE.Raycaster();
        const mouse = new THREE.Vector2();

        window.addEventListener('click', (event) => {
            mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
            mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;
            raycaster.setFromCamera(mouse, camera);
            const intersects = raycaster.intersectObjects([kettle1, kettle2], true);
            if (intersects.length > 0) {
                const kettle = intersects[0].object.parent;
                kettle.isPouring = !kettle.isPouring;
            }
        });

        // 水位高度控制
        let waterLevel = 0;
        const maxWaterLevel = 0.18;

        // 动画循环
        function animate() {
            requestAnimationFrame(animate);

            // 更新水壶倾斜（向中间）
            kettle1.rotation.z += kettle1.isPouring ? (-Math.PI / 4 - kettle1.rotation.z) * 0.1 : (0 - kettle1.rotation.z) * 0.1;
            kettle2.rotation.z += kettle2.isPouring ? (Math.PI / 4 - kettle2.rotation.z) * 0.1 : (0 - kettle2.rotation.z) * 0.1;

            // 生成水流粒子（从壶嘴位置）
            [kettle1, kettle2].forEach(kettle => {
                if (kettle.isPouring) {
                    const spoutPosition = new THREE.Vector3(kettle === kettle1 ? 0.3 : -0.3, 0.2, 0).applyMatrix4(kettle.matrixWorld);
                    createWaterParticle(spoutPosition);
                }
            });

            // 更新水粒子位置
            let waterFalling = false;
            for (let i = waterParticles.children.length - 1; i >= 0; i--) {
                const particle = waterParticles.children[i];
                particle.position.add(particle.velocity);
                particle.velocity.y -= 0.001;

                if (particle.position.y < 0.1 && Math.abs(particle.position.x) < 0.5 && Math.abs(particle.position.z) < 0.5) {
                    waterFalling = true;
                    waterParticles.remove(particle);
                } else if (particle.position.y < 0) {
                    waterParticles.remove(particle);
                }
            }

            // 更新水位
            if (waterFalling && waterLevel < maxWaterLevel) {
                waterLevel += 0.001;
            } else if (!waterFalling && waterLevel > 0) {
                waterLevel -= 0.0005;
            }
            waterSurface.position.y = waterLevel;

            // 小狗动画：头部摆动 + 尾巴摇晃
            dogHead.rotation.y = Math.sin(Date.now() * 0.005) * 0.2;
            tail.rotation.z = Math.PI / 4 + Math.sin(Date.now() * 0.01) * 0.3;

            renderer.render(scene, camera);
        }

        // 处理窗口大小调整
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

        // 启动动画
        animate();
    </script>
</body>
</html>